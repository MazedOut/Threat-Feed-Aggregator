// Threat Feed Aggregator (Google Sheets + Apps Script)
// Paste into Extensions -> Apps Script. Run fetchAndStoreFeeds once to authorize.
// Then set a time-driven trigger to run daily.

const FEEDS = [
  {name: "URLhaus", url: "https://urlhaus.abuse.ch/downloads/csv_recent/"},
  {name: "FeodoTracker", url: "https://feodotracker.abuse.ch/downloads/ipblocklist.csv"},
  {name: "PhishTank", url: "http://data.phishtank.com/data/online-valid.csv"}
];

function fetchText(url) {
  const options = {muteHttpExceptions: true, followRedirects: true, validateHttpsCertificates: true};
  try {
    const resp = UrlFetchApp.fetch(url, options);
    if (resp.getResponseCode() >= 200 && resp.getResponseCode() < 300) {
      return resp.getContentText();
    } else {
      Logger.log("Failed fetch: " + url + " code: " + resp.getResponseCode());
      return "";
    }
  } catch (e) {
    Logger.log("Fetch error: " + e);
    return "";
  }
}

function extractIndicatorsFromText(text) {
  const ipRe = /\b(?:\d{1,3}\.){3}\d{1,3}\b/g;
  const urlRe = /https?:\/\/[^\s"<>]+/ig;
  const sha256Re = /\b[a-fA-F0-9]{64}\b/g;
  const md5Re = /\b[a-fA-F0-9]{32}\b/g;
  const domainRe = /\b(?:[A-Za-z0-9-]+\.)+[A-Za-z]{2,}\b/g;

  const found = {};
  function pushMatches(re, t) {
    let m;
    while ((m = re.exec(text)) !== null) {
      const v = m[0].trim();
      if (v && v.length < 300) {
        found[v] = t;
      }
    }
  }
  pushMatches(urlRe, "url");
  pushMatches(sha256Re, "sha256");
  pushMatches(md5Re, "md5");
  pushMatches(ipRe, "ip");
  pushMatches(domainRe, "domain");
  return found; // object: indicator -> type
}

function getExistingIndicators_(sheet) {
  const last = sheet.getLastRow();
  if (last < 2) return {};
  const data = sheet.getRange(2,1,last-1,1).getValues();
  const exists = {};
  for (let i=0;i<data.length;i++) {
    const v = data[i][0];
    if (v) exists[v] = true;
  }
  return exists;
}

function fetchAndStoreFeeds() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const iocSheet = ss.getSheetByName("iocs");
  if (!iocSheet) {
    SpreadsheetApp.getUi().alert("Create a sheet named 'iocs' with headers first.");
    return;
  }

  const existing = getExistingIndicators_(iocSheet);
  const newRows = [];
  const now = new Date().toISOString();

  FEEDS.forEach(feed => {
    const text = fetchText(feed.url);
    if (!text) return;
    // Optionally, archive raw feed into raw sheet
  //  try {
  //    const rawSheet = ss.getSheetByName("raw");
  //    if (rawSheet) {
  //      rawSheet.insertRowBefore(2);
  //      rawSheet.getRange(2,1).setValue(`[${feed.name} @ ${now}]`);
  //      rawSheet.getRange(3,1).setValue(text);
  //    }
  // } catch(e){ Logger.log("raw save failed: "+e); }

    const indicators = extractIndicatorsFromText(text);
    Object.keys(indicators).forEach(ind => {
      if (!existing[ind]) {
        newRows.push([ind, indicators[ind], feed.name, now, ""]);
        existing[ind] = true; // avoid duplicates inside run
      }
    });
  });

  if (newRows.length > 0) {
    iocSheet.getRange(iocSheet.getLastRow()+1, 1, newRows.length, newRows[0].length).setValues(newRows);
    Logger.log("Appended " + newRows.length + " new indicators.");
  } else {
    Logger.log("No new indicators found in this run.");
  }
}
function doGet(e) {
  // Run your main function
  fetchAndStoreFeeds();
  
  // return a simple message in the browser
  return ContentService.createTextOutput("Threat Feed Aggregator ran successfully!");
}
